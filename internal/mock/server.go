package mock

import (
	"context"
	"encoding/json"
	"fmt"
	"log"
	"math/rand"
	"net"
	"net/http"
	"net/url"
	"strings"
	"time"

	"github.com/google/uuid"
	"github.com/serdar/gottp/internal/core/collection"
)

// route represents a matched collection request mapped to an HTTP endpoint.
type route struct {
	method  string
	path    string
	body    string
	headers map[string]string
	status  int
}

// Method returns the HTTP method for this route.
func (r route) Method() string { return r.method }

// Path returns the URL path for this route.
func (r route) Path() string { return r.path }

// Status returns the HTTP status code for this route.
func (r route) Status() int { return r.status }

// Server is a mock HTTP server that serves canned responses from a collection.
type Server struct {
	collection *collection.Collection
	routes     []route
	latency    time.Duration
	errorRate  float64
	port       int
	corsOrigin string
}

// Option configures a Server.
type Option func(*Server)

// WithPort sets the port the mock server listens on.
func WithPort(port int) Option {
	return func(s *Server) {
		s.port = port
	}
}

// WithLatency sets an artificial delay before each response.
func WithLatency(d time.Duration) Option {
	return func(s *Server) {
		s.latency = d
	}
}

// WithErrorRate sets the probability (0.0 to 1.0) of returning a random 500 error.
func WithErrorRate(rate float64) Option {
	return func(s *Server) {
		if rate < 0 {
			rate = 0
		}
		if rate > 1 {
			rate = 1
		}
		s.errorRate = rate
	}
}

// WithCORSOrigin sets the Access-Control-Allow-Origin header value.
// Defaults to "*" if not set.
func WithCORSOrigin(origin string) Option {
	return func(s *Server) {
		s.corsOrigin = origin
	}
}

// New creates a new mock Server from a collection.
func New(col *collection.Collection, opts ...Option) *Server {
	s := &Server{
		collection: col,
		port:       8080,
		corsOrigin: "*",
	}
	for _, opt := range opts {
		opt(s)
	}
	s.routes = buildRoutes(col.Items)
	return s
}

// Routes returns the list of registered routes.
func (s *Server) Routes() []route {
	return s.routes
}

// Handler returns the http.Handler for the mock server. Useful for testing.
func (s *Server) Handler() http.Handler {
	mux := http.NewServeMux()
	mux.HandleFunc("/", s.handleRequest)
	return mux
}

// Start starts the mock server and blocks until the context is cancelled.
func (s *Server) Start(ctx context.Context) error {
	handler := s.Handler()

	addr := fmt.Sprintf(":%d", s.port)
	srv := &http.Server{
		Addr:    addr,
		Handler: handler,
	}

	// Use a listener so we can get the actual port (useful if port 0 is used).
	ln, err := net.Listen("tcp", addr)
	if err != nil {
		return fmt.Errorf("listen on %s: %w", addr, err)
	}

	actualPort := ln.Addr().(*net.TCPAddr).Port
	s.port = actualPort

	log.Printf("Mock server starting on http://localhost:%d", actualPort)
	log.Printf("Serving %d route(s) from collection %q", len(s.routes), s.collection.Name)
	for _, r := range s.routes {
		log.Printf("  %-7s %s", r.method, r.path)
	}

	errCh := make(chan error, 1)
	go func() {
		if err := srv.Serve(ln); err != nil && err != http.ErrServerClosed {
			errCh <- err
		}
		close(errCh)
	}()

	select {
	case <-ctx.Done():
		shutdownCtx, cancel := context.WithTimeout(context.Background(), 5*time.Second)
		defer cancel()
		if err := srv.Shutdown(shutdownCtx); err != nil {
			return fmt.Errorf("server shutdown: %w", err)
		}
		return nil
	case err := <-errCh:
		return err
	}
}

// Port returns the port the server is configured to listen on.
// After Start is called, this reflects the actual listening port.
func (s *Server) Port() int {
	return s.port
}

func (s *Server) handleRequest(w http.ResponseWriter, r *http.Request) {
	start := time.Now()

	// CORS headers
	w.Header().Set("Access-Control-Allow-Origin", s.corsOrigin)
	w.Header().Set("Access-Control-Allow-Methods", "GET, POST, PUT, PATCH, DELETE, OPTIONS, HEAD")
	w.Header().Set("Access-Control-Allow-Headers", "Content-Type, Authorization, X-Requested-With")
	w.Header().Set("Access-Control-Max-Age", "86400")

	// Handle preflight
	if r.Method == http.MethodOptions {
		w.WriteHeader(http.StatusNoContent)
		log.Printf("%-7s %s -> %d (%s)", r.Method, r.URL.Path, http.StatusNoContent, time.Since(start))
		return
	}

	// Artificial latency
	if s.latency > 0 {
		time.Sleep(s.latency)
	}

	// Error simulation
	if s.errorRate > 0 && rand.Float64() < s.errorRate {
		status := http.StatusInternalServerError
		w.Header().Set("Content-Type", "application/json")
		w.WriteHeader(status)
		resp := map[string]string{
			"error":   "Simulated server error",
			"message": "This error was randomly generated by the mock server error rate simulation",
		}
		_ = json.NewEncoder(w).Encode(resp)
		log.Printf("%-7s %s -> %d (simulated error) (%s)", r.Method, r.URL.Path, status, time.Since(start))
		return
	}

	// Find matching route
	matched := s.matchRoute(r.Method, r.URL.Path)
	if matched == nil {
		s.handleNotFound(w, r, start)
		return
	}

	// Set response headers
	for k, v := range matched.headers {
		w.Header().Set(k, v)
	}

	// Auto-detect Content-Type if not explicitly set
	if w.Header().Get("Content-Type") == "" && matched.body != "" {
		w.Header().Set("Content-Type", detectContentType(matched.body))
	}

	body := expandTemplateVars(matched.body)

	w.WriteHeader(matched.status)
	if body != "" {
		fmt.Fprint(w, body)
	}

	log.Printf("%-7s %s -> %d (%s)", r.Method, r.URL.Path, matched.status, time.Since(start))
}

func (s *Server) matchRoute(method, path string) *route {
	// Normalize path
	path = normalizePath(path)

	for i := range s.routes {
		if strings.EqualFold(s.routes[i].method, method) && s.routes[i].path == path {
			return &s.routes[i]
		}
	}
	return nil
}

func (s *Server) handleNotFound(w http.ResponseWriter, r *http.Request, start time.Time) {
	w.Header().Set("Content-Type", "application/json")
	w.WriteHeader(http.StatusNotFound)

	available := make([]map[string]string, 0, len(s.routes))
	for _, rt := range s.routes {
		available = append(available, map[string]string{
			"method": rt.method,
			"path":   rt.path,
		})
	}

	resp := map[string]interface{}{
		"error":            "Route not found",
		"message":          fmt.Sprintf("No mock route matches %s %s", r.Method, r.URL.Path),
		"available_routes": available,
	}
	_ = json.NewEncoder(w).Encode(resp)

	log.Printf("%-7s %s -> 404 (no match) (%s)", r.Method, r.URL.Path, time.Since(start))
}

// buildRoutes extracts HTTP routes from collection items recursively.
func buildRoutes(items []collection.Item) []route {
	var routes []route
	for _, item := range items {
		if item.Request != nil {
			r := requestToRoute(item.Request)
			if r != nil {
				routes = append(routes, *r)
			}
		}
		if item.Folder != nil {
			routes = append(routes, buildRoutes(item.Folder.Items)...)
		}
	}
	return routes
}

func requestToRoute(req *collection.Request) *route {
	// Only handle HTTP/GraphQL requests (they use HTTP transport).
	proto := strings.ToLower(req.Protocol)
	if proto != "" && proto != "http" && proto != "graphql" {
		return nil
	}

	method := strings.ToUpper(req.Method)
	if method == "" {
		method = "GET"
	}

	path := extractPath(req.URL)

	r := &route{
		method:  method,
		path:    path,
		status:  http.StatusOK,
		headers: make(map[string]string),
	}

	// Use request body as the mock response body
	if req.Body != nil && req.Body.Content != "" {
		r.body = req.Body.Content

		// Set Content-Type based on body type
		switch strings.ToLower(req.Body.Type) {
		case "json":
			r.headers["Content-Type"] = "application/json"
		case "xml":
			r.headers["Content-Type"] = "application/xml"
		case "text":
			r.headers["Content-Type"] = "text/plain"
		case "form":
			r.headers["Content-Type"] = "application/x-www-form-urlencoded"
		}
	}

	// GraphQL always responds as JSON
	if proto == "graphql" && r.headers["Content-Type"] == "" {
		r.headers["Content-Type"] = "application/json"
	}

	return r
}

// extractPath parses a URL and returns just the path component.
// If the URL has no scheme, it tries to extract a path-like portion.
func extractPath(rawURL string) string {
	if rawURL == "" {
		return "/"
	}

	// If the URL contains template variables like {{baseUrl}}/users,
	// strip everything before the first slash that follows }}.
	if strings.Contains(rawURL, "{{") {
		// Find the closing }} and then the next /
		idx := strings.Index(rawURL, "}}")
		if idx >= 0 {
			rest := rawURL[idx+2:]
			slashIdx := strings.Index(rest, "/")
			if slashIdx >= 0 {
				return normalizePath(rest[slashIdx:])
			}
		}
		return "/"
	}

	// Try standard URL parsing for URLs with scheme.
	parsed, err := url.Parse(rawURL)
	if err == nil && parsed.Scheme != "" {
		path := parsed.Path
		if path == "" || path == "/" {
			return "/"
		}
		return normalizePath(path)
	}

	// Fallback: if URL contains no scheme but has slash, extract from first slash.
	idx := strings.Index(rawURL, "/")
	if idx >= 0 {
		return normalizePath(rawURL[idx:])
	}

	return "/"
}

// normalizePath ensures the path starts with / and has no trailing slash (except root).
func normalizePath(path string) string {
	if path == "" || path == "/" {
		return "/"
	}
	if !strings.HasPrefix(path, "/") {
		path = "/" + path
	}
	// Remove trailing slash (but keep root)
	path = strings.TrimRight(path, "/")
	if path == "" {
		path = "/"
	}
	return path
}

// detectContentType guesses content type from body content.
func detectContentType(body string) string {
	trimmed := strings.TrimSpace(body)
	if len(trimmed) == 0 {
		return "text/plain"
	}
	// JSON detection
	if (trimmed[0] == '{' && trimmed[len(trimmed)-1] == '}') ||
		(trimmed[0] == '[' && trimmed[len(trimmed)-1] == ']') {
		return "application/json"
	}
	// XML detection
	if trimmed[0] == '<' {
		return "application/xml"
	}
	return "text/plain"
}

// expandTemplateVars replaces dynamic template variables in response bodies.
func expandTemplateVars(body string) string {
	if !strings.Contains(body, "{{") {
		return body
	}
	body = strings.ReplaceAll(body, "{{$timestamp}}", fmt.Sprintf("%d", time.Now().Unix()))
	body = strings.ReplaceAll(body, "{{$uuid}}", uuid.New().String())
	body = strings.ReplaceAll(body, "{{$randomInt}}", fmt.Sprintf("%d", rand.Intn(10000)))
	return body
}
